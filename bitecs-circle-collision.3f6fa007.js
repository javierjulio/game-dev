var e,t={i8:"i8",ui8:"ui8",ui8c:"ui8c",i16:"i16",ui16:"ui16",i32:"i32",ui32:"ui32",f32:"f32",f64:"f64",eid:"eid"},n={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},r={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},o=256,s=65536,i=(e=4,t=>Math.ceil(t/e)*e),a=Symbol("storeRef"),l=Symbol("storeSize"),c=Symbol("storeMaps"),u=Symbol("storeFlattened"),y=Symbol("storeBase"),d=Symbol("storeType"),f=Symbol("storeArrayElementCounts"),h=Symbol("storeSubarrays"),m=Symbol("subarrayCursors"),b=Symbol("subarray"),p=Symbol("subarrayFrom"),S=Symbol("subarrayTo"),g=Symbol("subStore"),w=Symbol("tagStore"),E=(Symbol("queryShadow"),Symbol("serializeShadow"),Symbol("indexType")),M=Symbol("indexBytes"),x=Symbol("isEidType"),A={},v=(e,t)=>{const n=new ArrayBuffer(t*e.BYTES_PER_ELEMENT),r=new e.constructor(n);return r.set(e,0),r},R=(e,t)=>{if(ArrayBuffer.isView(e))e[t]=e.slice(0);else{const n=e[g].slice(0);e[t]=e.map(((t,r)=>{const o=e[r][p],s=e[r][S];return n.subarray(o,s)}))}},C=(e,a,l)=>{Object.keys(a).forEach((c=>{const y=a[c];Array.isArray(y)?(((e,a,l)=>{const c=e[m];let u=a[d];const y=a[0].length,w=y<=o?t.ui8:y<=s?t.ui16:t.ui32;if(0===c[u]){const t=e[f][u],o=new r[u](i(t*l));o.set(e[h][u]),e[h][u]=o,o[E]=n[w],o[M]=r[w].BYTES_PER_ELEMENT}const x=c[u];let A=0;for(let t=0;t<l;t++){const o=c[u]+t*y,s=o+y;a[t]=e[h][u].subarray(o,s),a[t][p]=o,a[t][S]=s,a[t][b]=!0,a[t][E]=n[w],a[t][M]=r[w].BYTES_PER_ELEMENT,A=s}c[u]=A,a[g]=e[h][u].subarray(x,A)})(e,y,l),a[u].push(y)):ArrayBuffer.isView(y)?(a[c]=v(y,l),a[u].push(a[c])):"object"==typeof y&&C(e,a[c],l)}))},O=(e,t)=>{e[w]||(e[l]=t,e[u].length=0,Object.keys(e[m]).forEach((t=>{e[m][t]=0})),C(e,e,t))},k=(e,t)=>{e[u]&&e[u].forEach((e=>{ArrayBuffer.isView(e)?e[t]=0:e[t].fill(0)}))},T=e=>Array.isArray(e)&&"string"==typeof e[0]&&"number"==typeof e[1],j=(e,v)=>{const R=Symbol("store");if(!e||!Object.keys(e).length)return A[R]={[l]:v,[w]:!0,[y]:()=>A[R]},A[R];e=JSON.parse(JSON.stringify(e));const C={},O=e=>{const t=Object.keys(e);for(const n of t)T(e[n])?(C[e[n][0]]||(C[e[n][0]]=0),C[e[n][0]]+=e[n][1]):e[n]instanceof Object&&O(e[n])};O(e);const k={[l]:v,[c]:{},[h]:{},[a]:R,[m]:Object.keys(r).reduce(((e,t)=>({...e,[t]:0})),{}),[u]:[],[f]:C};if(e instanceof Object&&Object.keys(e).length){const a=(e,c)=>{if("string"==typeof e[c])e[c]=((e,n)=>{const o=n*r[e].BYTES_PER_ELEMENT,s=new ArrayBuffer(o),i=new r[e](s);return i[x]=e===t.eid,i})(e[c],v),e[c][y]=()=>A[R],k[u].push(e[c]);else if(T(e[c])){const[a,w]=e[c];e[c]=((e,a,c)=>{const u=e[l],y=Array(u).fill(0);y[d]=a,y[x]=a===t.eid;const w=e[m],A=c<=o?t.ui8:c<=s?t.ui16:t.ui32;if(!c)throw new Error("bitECS - Must define component array length");if(!r[a])throw new Error(`bitECS - Invalid component array property type ${a}`);if(!e[h][a]){const t=e[f][a],o=new r[a](i(t*u));e[h][a]=o,o[E]=n[A],o[M]=r[A].BYTES_PER_ELEMENT}const v=w[a];let R=0;for(let t=0;t<u;t++){const o=w[a]+t*c,s=o+c;y[t]=e[h][a].subarray(o,s),y[t][p]=o,y[t][S]=s,y[t][b]=!0,y[t][E]=n[A],y[t][M]=r[A].BYTES_PER_ELEMENT,R=s}return w[a]=R,y[g]=e[h][a].subarray(v,R),y})(k,a,w),e[c][y]=()=>A[R],k[u].push(e[c])}else e[c]instanceof Object&&(e[c]=Object.keys(e[c]).reduce(a,e[c]));return e};return A[R]=Object.assign(Object.keys(e).reduce(a,e),k),A[R][y]=()=>A[R],A[R]}},I=()=>{const e=[],t=[];e.sort=function(n){const r=Array.prototype.sort.call(this,n);for(let n=0;n<e.length;n++)t[e[n]]=n;return r};const n=n=>e[t[n]]===n;return{add:r=>{n(r)||(t[r]=e.push(r)-1)},remove:r=>{if(!n(r))return;const o=t[r],s=e.pop();s!==r&&(e[o]=s,t[s]=o)},has:n,sparse:t,dense:e}},P=e=>t=>!e(t),B=e=>e[u],q=B,U=(P(q),e=>"function"==typeof e),_=(P(U),new Map,Symbol("entityMasks")),z=Symbol("entityComponents"),N=Symbol("entitySparseSet"),F=Symbol("entityArray"),L=(Symbol("entityIndices"),Symbol("removedEntities"),1e5),Q=0,$=L,Y=()=>$,V=[],J=new Map,H=e=>{if(Q>=$-$/5){const e=$,t=e+4*Math.ceil(e/2/4);$=t,ve(t),fe(t),!0,console.info(`ðŸ‘¾ bitECS - resizing all data stores from ${e} to ${t}`)}const t=V.length>0?V.shift():Q++;return e[N].add(t),J.set(t,e),e[D].forEach((n=>{ie(e,n,t)&&ae(n,t)})),e[z].set(t,new Set),t};var W=Symbol("queries"),D=Symbol("notQueries"),G=Symbol("queryAny"),K=Symbol("queryAll"),X=Symbol("queryNone"),Z=Symbol("queryMap"),ee=Symbol("$dirtyQueries"),te=Symbol("queryComponents"),ne=(Symbol("enterQuery"),Symbol("exitQuery"),(e,t)=>{const n=[],r=[],o=[];t[te].forEach((t=>{if("function"==typeof t){const[s,i]=t();e[ye].has(s)||me(e,s),"not"===i&&r.push(s),"changed"===i&&(o.push(s),n.push(s))}else e[ye].has(t)||me(e,t),n.push(t)}));const s=t=>e[ye].get(t),i=n.concat(r).map(s),a=I(),l=I(),c=I(),y=I(),d=i.map((e=>e.generationId)).reduce(((e,t)=>(e.includes(t)||e.push(t),e)),[]),f=(e,t)=>(e[t.generationId]||(e[t.generationId]=0),e[t.generationId]|=t.bitflag,e),h=n.map(s).reduce(f,{}),m=r.map(s).reduce(f,{}),b=i.reduce(f,{}),p=n.filter((e=>!e[w])).map((e=>Object.getOwnPropertySymbols(e).includes(u)?e[u]:[e])).reduce(((e,t)=>e.concat(t)),[]),S=p.map((e=>{const t=Symbol();return R(e,t),e[t]}),[]),g=Object.assign(a,{archetypes:[],changed:[],components:n,notComponents:r,changedComponents:o,allComponents:i,masks:h,notMasks:m,hasMasks:b,generations:d,flatProps:p,toRemove:l,entered:c,exited:y,shadows:S});e[Z].set(t,g),e[W].add(g),i.forEach((e=>{e.queries.add(g)})),r.length&&e[D].add(g);for(let t=0;t<Q;t++){if(!e[N].has(t))continue;ie(e,g,t)&&ae(g,t)}}),re=(e,t)=>e.concat(t),oe=e=>t=>t.filter((t=>t.name===e().constructor.name)).reduce(re),se=(oe((function(...e){return function(){return e}})),oe((function(...e){return function(){return e}})),oe((function(...e){return function(){return e}})),(...e)=>{let t;if(Array.isArray(e[0])&&(t=e[0]),void 0===t||void 0!==t[ye])return e=>e?e[F]:t[F];const n=function(e,t=!0){e[Z].has(n)||ne(e,n);const r=e[Z].get(n);return ce(e),r.changedComponents.length?((e,t)=>{t&&(e.changed=[]);const{flatProps:n,shadows:r}=e;for(let t=0;t<e.dense.length;t++){const o=e.dense[t];let s=!1;for(let e=0;e<n.length;e++){const t=n[e],i=r[e];if(ArrayBuffer.isView(t[o])){for(let e=0;e<t[o].length;e++)if(t[o][e]!==i[o][e]){s=!0;break}i[o].set(t[o])}else t[o]!==i[o]&&(s=!0,i[o]=t[o])}s&&e.changed.push(o)}return e.changed})(r,t):r.dense};return n[te]=t,n[G]=undefined,n[K]=undefined,n[X]=undefined,n}),ie=(e,t,n)=>{const{masks:r,notMasks:o,generations:s}=t;for(let t=0;t<s.length;t++){const i=s[t],a=r[i],l=o[i],c=e[_][i][n];if(l&&0!=(c&l))return!1;if(a&&(c&a)!==a)return!1}return!0},ae=(e,t)=>{e.toRemove.remove(t),e.has(t)||e.entered.add(t),e.add(t)},le=e=>{for(let t=e.toRemove.dense.length-1;t>=0;t--){const n=e.toRemove.dense[t];e.toRemove.remove(n),e.remove(n)}},ce=e=>{e[ee].size&&(e[ee].forEach(le),e[ee].clear())},ue=(e,t,n)=>{t.has(n)&&!t.toRemove.has(n)&&(t.toRemove.add(n),e[ee].add(t),t.exited.add(n))},ye=Symbol("componentMap"),de=[],fe=e=>{de.forEach((t=>O(t,e)))},he=e=>{const t=j(e,Y());return e&&Object.keys(e).length&&de.push(t),t},me=(e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");const n=new Set,r=new Set,o=new Set;e[W].forEach((e=>{e.allComponents.includes(t)&&n.add(e)})),e[ye].set(t,{generationId:e[_].length-1,bitflag:e[we],store:t,queries:n,notQueries:r,changedQueries:o}),t[l]<Y()&&O(t,Y()),(e=>{e[we]*=2,e[we]>=2**31&&(e[we]=1,e[_].push(new Uint32Array(e[Se])))})(e)},be=(e,t,n)=>{const r=e[ye].get(t);if(!r)return!1;const{generationId:o,bitflag:s}=r;return(e[_][o][n]&s)===s},pe=(e,t,n,r=!0)=>{if(void 0===n)throw new Error("bitECS - entity is undefined.");if(!e[N].has(n))throw new Error("bitECS - entity does not exist in the world.");if(e[ye].has(t)||me(e,t),be(e,t,n))return;const o=e[ye].get(t),{generationId:s,bitflag:i,queries:a,notQueries:l}=o;e[_][s][n]|=i,a.forEach((t=>{t.toRemove.has(n)&&t.toRemove.remove(n);const r=ie(e,t,n);r&&ae(t,n),r||ue(e,t,n)})),e[z].get(n).add(t),r&&k(t,n)},Se=Symbol("size"),ge=Symbol("resizeThreshold"),we=Symbol("bitflag"),Ee=Symbol("archetypes"),Me=Symbol("localEntities"),xe=Symbol("localEntityLookp"),Ae=[],ve=e=>{Ae.forEach((t=>{t[Se]=e;for(let n=0;n<t[_].length;n++){const r=t[_][n];t[_][n]=v(r,e)}t[ge]=t[Se]-t[Se]/5}))},Re=e=>{const t=Y();return e[Se]=t,e[F]&&e[F].forEach((t=>((e,t)=>{if(e[N].has(t)){e[W].forEach((n=>{ue(e,n,t)})),V.push(t),e[N].remove(t),e[z].delete(t),e[Me].delete(e[xe].get(t)),e[xe].delete(t);for(let n=0;n<e[_].length;n++)e[_][n][t]=0}})(e,t))),e[_]=[new Uint32Array(t)],e[z]=new Map,e[Ee]=[],e[N]=I(),e[F]=e[N].dense,e[we]=1,e[ye]=new Map,e[Z]=new Map,e[W]=new Set,e[D]=new Set,e[ee]=new Set,e[Me]=new Map,e[xe]=new Map,e},Ce=t;const Oe={x:Ce.f32,y:Ce.f32,z:Ce.f32},ke=he(Oe),Te=he(Oe),je=he({radius:Ce.f32,color:Ce.f32}),Ie=se([ke,Te]),Pe=se([ke,Te,je]),Be=se([ke,Te,je]);let qe=document.querySelector("canvas"),Ue=qe.getContext("2d"),_e=qe.width=window.innerWidth,ze=qe.height=window.innerHeight;window.devicePixelRatio>1&&(qe.width=_e*window.devicePixelRatio,qe.height=ze*window.devicePixelRatio,qe.style.width=`${_e}px`,qe.style.height=`${ze}px`,Ue.scale(window.devicePixelRatio,window.devicePixelRatio));const Ne=((...e)=>t=>{let n=t;for(let t=0;t<e.length;t++){n=(0,e[t])(n)}return n})((e=>{const t=Ie(e);for(let e=0;e<t.length;e++){const n=t[e];ke.x[n]+=Te.x[n],ke.y[n]+=Te.y[n],ke.z[n]+=Te.z[n],ke.x[n]-je.radius[n]<0?Te.x[n]=Math.abs(Te.x[n]):ke.x[n]+je.radius[n]>_e&&(Te.x[n]=-Math.abs(Te.x[n])),ke.y[n]-je.radius[n]<0?Te.y[n]=Math.abs(Te.y[n]):ke.y[n]+je.radius[n]>ze&&(Te.y[n]=-Math.abs(Te.y[n]))}return e}),(e=>{const t=Be(e);for(let e=0;e<t.length;e++){const s=t[e],i=t.slice(e+1);for(let e=0;e<i.length;e++){const t=i[e];var n=ke.x[s]-ke.x[t],r=ke.y[s]-ke.y[t],o=Math.sqrt(Math.pow(n,2)+Math.pow(r,2));if(o<=je.radius[s]+je.radius[t]){const e=(ke.x[s]-ke.x[t])/o,n=(ke.y[s]-ke.y[t])/o,r=-n,i=e,a=Te.x[s]*e+Te.y[s]*n,l=Te.x[t]*e+Te.y[t]*n,c=Te.x[s]*r+Te.y[s]*i,u=Te.x[t]*r+Te.y[t]*i,y=(a*(je.radius[s]-je.radius[t])+2*je.radius[t]*l)/(je.radius[s]+je.radius[t]),d=(l*(je.radius[t]-je.radius[s])+2*je.radius[s]*a)/(je.radius[s]+je.radius[t]),f=e*y,h=n*y,m=e*d,b=n*d,p=r*c,S=i*c,g=r*u,w=i*u;Te.x[s]=f+p,Te.y[s]=h+S,Te.x[t]=m+g,Te.y[t]=b+w}}}return e}),(e=>{const t=Pe(e);Ue.clearRect(0,0,_e,ze);for(let e=0;e<t.length;e++){const n=t[e];Ue.beginPath(),Ue.arc(ke.x[n],ke.y[n],je.radius[n],0,2*Math.PI),Ue.fillStyle=`hsl(${je.color[n]}, 50%, 50%)`,Ue.fill()}return e}),(e=>{const{time:t}=e,n=performance.now(),r=n-t.then;return t.delta=r,t.elapsed+=r,t.then=n,e})),Fe=((e={})=>{const t=e;return Re(t),Ae.push(t),t})();Fe.time={delta:0,elapsed:0,then:performance.now()};const Le=(e,t,n,r,o)=>{const s=H(Fe);pe(Fe,ke,s),ke.x[s]=e,ke.y[s]=t,pe(Fe,Te,s),Te.x[s]=n,Te.y[s]=r,pe(Fe,je,s),je.radius[s]=o,je.color[s]=360*Math.random()},Qe=[],$e=ze-32,Ye=_e-32;for(let e=32;e<Ye;e+=64)for(let t=32;t<$e;t+=64)Qe.push({x:e,y:t});const Ve=Math.min(100,Qe.length);for(let e=0;e<Ve;e++){const e=Math.floor(Math.random()*Qe.length),t=Qe.splice(e,1)[0];Le(t.x,t.y,.4*(2*Math.random()-1),.4*(2*Math.random()-1),Math.floor((Je=8,He=32,Math.random()*(He-Je)+Je)))}var Je,He;window.generateEntity=Le;const We=()=>{Ne(Fe),requestAnimationFrame(We)};window.run=We,We();
//# sourceMappingURL=bitecs-circle-collision.3f6fa007.js.map
