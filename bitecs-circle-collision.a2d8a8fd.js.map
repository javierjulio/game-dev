{"mappings":"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","sources":["node_modules/bitecs/src/Constants.js","node_modules/bitecs/src/Storage.js","node_modules/bitecs/src/Util.js","node_modules/bitecs/src/Serialize.js","node_modules/bitecs/src/Entity.js","node_modules/bitecs/src/Query.js","node_modules/bitecs/src/Component.js","node_modules/bitecs/src/World.js","node_modules/bitecs/src/index.js","src/bitecs-circle-collision/index.js"],"sourcesContent":["export const TYPES_ENUM = {\n  i8: 'i8',\n  ui8: 'ui8',\n  ui8c: 'ui8c',\n  i16: 'i16',\n  ui16: 'ui16',\n  i32: 'i32',\n  ui32: 'ui32',\n  f32: 'f32',\n  f64: 'f64',\n  eid: 'eid',\n}\n\nexport const TYPES_NAMES = {\n  i8: 'Int8',\n  ui8: 'Uint8',\n  ui8c: 'Uint8Clamped',\n  i16: 'Int16',\n  ui16: 'Uint16',\n  i32: 'Int32',\n  ui32: 'Uint32',\n  eid: 'Uint32',\n  f32: 'Float32',\n  f64: 'Float64'\n}\n\nexport const TYPES = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  f32: Float32Array,\n  f64: Float64Array,\n  eid: Uint32Array,\n}\n\nexport const UNSIGNED_MAX = {\n  uint8: 2**8,\n  uint16: 2**16,\n  uint32: 2**32\n}\n","import { TYPES, TYPES_ENUM, TYPES_NAMES, UNSIGNED_MAX } from './Constants.js'\n// import { createAllocator } from './Allocator.js'\n\nconst roundToMultiple = mul => x => Math.ceil(x / mul) * mul\nconst roundToMultiple4 = roundToMultiple(4)\n\nexport const $storeRef = Symbol('storeRef')\nexport const $storeSize = Symbol('storeSize')\nexport const $storeMaps = Symbol('storeMaps')\nexport const $storeFlattened = Symbol('storeFlattened')\nexport const $storeBase = Symbol('storeBase')\nexport const $storeType = Symbol('storeType')\n\nexport const $storeArrayElementCounts = Symbol('storeArrayElementCounts')\nexport const $storeSubarrays = Symbol('storeSubarrays')\nexport const $subarrayCursors = Symbol('subarrayCursors')\nexport const $subarray = Symbol('subarray')\nexport const $subarrayFrom = Symbol('subarrayFrom')\nexport const $subarrayTo = Symbol('subarrayTo')\nexport const $parentArray = Symbol('subStore')\nexport const $tagStore = Symbol('tagStore')\n\nexport const $queryShadow = Symbol('queryShadow')\nexport const $serializeShadow = Symbol('serializeShadow')\n\nexport const $indexType = Symbol('indexType')\nexport const $indexBytes = Symbol('indexBytes')\n\nexport const $isEidType = Symbol('isEidType')\n\nconst stores = {}\n\n// const alloc = createAllocator()\n\nexport const resize = (ta, size) => {\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\n  const newTa = new ta.constructor(newBuffer)\n  newTa.set(ta, 0)\n  return newTa\n}\n\nexport const createShadow = (store, key) => {\n  if (!ArrayBuffer.isView(store)) {\n    const shadowStore = store[$parentArray].slice(0)\n    store[key] = store.map((_,eid) => {\n      const from = store[eid][$subarrayFrom]\n      const to = store[eid][$subarrayTo]\n      return shadowStore.subarray(from, to)\n    })\n  } else {\n    store[key] = store.slice(0)\n  }\n}\n\nconst resizeSubarray = (metadata, store, size) => {\n  const cursors = metadata[$subarrayCursors]\n  let type = store[$storeType]\n  const length = store[0].length\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (cursors[type] === 0) {\n\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n    \n    // // for threaded impl\n    // // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * size))\n\n    array.set(metadata[$storeSubarrays][type])\n    \n    metadata[$storeSubarrays][type] = array\n    \n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n  }\n\n  const start = cursors[type]\n  let end = 0\n  for (let eid = 0; eid < size; eid++) {\n    const from = cursors[type] + (eid * length)\n    const to = from + length\n\n    store[eid] = metadata[$storeSubarrays][type].subarray(from, to)\n    \n    store[eid][$subarrayFrom] = from\n    store[eid][$subarrayTo] = to\n    store[eid][$subarray] = true\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    \n    end = to\n  }\n\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n}\n\nconst resizeRecursive = (metadata, store, size) => {\n  Object.keys(store).forEach(key => {\n    const ta = store[key]\n    if (Array.isArray(ta)) {\n      resizeSubarray(metadata, ta, size)\n      store[$storeFlattened].push(ta)\n    } else if (ArrayBuffer.isView(ta)) {\n      store[key] = resize(ta, size)\n      store[$storeFlattened].push(store[key])\n    } else if (typeof ta === 'object') {\n      resizeRecursive(metadata, store[key], size)\n    }\n  })\n}\n\nexport const resizeStore = (store, size) => {\n  if (store[$tagStore]) return\n  store[$storeSize] = size\n  store[$storeFlattened].length = 0\n  Object.keys(store[$subarrayCursors]).forEach(k => {\n    store[$subarrayCursors][k] = 0\n  })\n  resizeRecursive(store, store, size)\n}\n\nexport const resetStore = store => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      ta.fill(0)\n    })\n    Object.keys(store[$storeSubarrays]).forEach(key => {\n      store[$storeSubarrays][key].fill(0)\n    })\n  }\n}\n\nexport const resetStoreFor = (store, eid) => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\n      else ta[eid].fill(0)\n    })\n  }\n}\n\n// const createTypeStore = (type, length) => {\n//   const store = alloc(type, length)\n//   store[$isEidType] = type === TYPES_ENUM.eid\n//   return store\n// }\nconst createTypeStore = (type, length) => {\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\n  const buffer = new ArrayBuffer(totalBytes)\n  const store = new TYPES[type](buffer)\n  store[$isEidType] = type === TYPES_ENUM.eid\n  return store\n}\n\nexport const parentArray = store => store[$parentArray]\n\nconst createArrayStore = (metadata, type, length) => {\n  const size = metadata[$storeSize]\n  const store = Array(size).fill(0)\n  store[$storeType] = type\n  store[$isEidType] = type === TYPES_ENUM.eid\n\n  const cursors = metadata[$subarrayCursors]\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (!length) throw new Error('bitECS - Must define component array length')\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\n\n  // create buffer for type if it does not already exist\n  if (!metadata[$storeSubarrays][type]) {\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n\n    // for threaded impl\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * size))\n\n    metadata[$storeSubarrays][type] = array\n    \n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n  }\n\n  // pre-generate subarrays for each eid\n  const start = cursors[type]\n  let end = 0\n  for (let eid = 0; eid < size; eid++) {\n    const from = cursors[type] + (eid * length)\n    const to = from + length\n\n    store[eid] = metadata[$storeSubarrays][type].subarray(from, to)\n    \n    store[eid][$subarrayFrom] = from\n    store[eid][$subarrayTo] = to\n    store[eid][$subarray] = true\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    \n    end = to\n  }\n\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  return store\n}\n\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\n\nexport const createStore = (schema, size) => {\n  const $store = Symbol('store')\n\n  if (!schema || !Object.keys(schema).length) {\n    // tag component\n    stores[$store] = {\n      [$storeSize]: size,\n      [$tagStore]: true,\n      [$storeBase]: () => stores[$store]\n    }\n    return stores[$store]\n  }\n\n  schema = JSON.parse(JSON.stringify(schema))\n\n  const arrayElementCounts = {}\n  const collectArrayElementCounts = s => {\n    const keys = Object.keys(s)\n    for (const k of keys) {\n      if (isArrayType(s[k])) {\n        if (!arrayElementCounts[s[k][0]]) arrayElementCounts[s[k][0]] = 0\n        arrayElementCounts[s[k][0]] += s[k][1]\n      } else if (s[k] instanceof Object) {\n        collectArrayElementCounts(s[k])\n      }\n    }\n  }\n  collectArrayElementCounts(schema)\n\n  const metadata = {\n    [$storeSize]: size,\n    [$storeMaps]: {},\n    [$storeSubarrays]: {},\n    [$storeRef]: $store,\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\n    [$storeFlattened]: [],\n    [$storeArrayElementCounts]: arrayElementCounts\n  }\n\n  if (schema instanceof Object && Object.keys(schema).length) {\n\n    const recursiveTransform = (a, k) => {\n\n      if (typeof a[k] === 'string') {\n\n        a[k] = createTypeStore(a[k], size)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n\n      } else if (isArrayType(a[k])) {\n        \n        const [type, length] = a[k]\n        a[k] = createArrayStore(metadata, type, length)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n        // Object.seal(a[k])\n\n      } else if (a[k] instanceof Object) {\n        \n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\n        // Object.seal(a[k])\n        \n      }\n\n      return a\n    }\n\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\n    stores[$store][$storeBase] = () => stores[$store]\n\n    // Object.seal(stores[$store])\n\n    return stores[$store]\n\n  }\n}\n\nexport const free = (store) => {\n  delete stores[store[$storeRef]]\n}","export const Uint32SparseSet = (length) => {\n  const dense = new Uint32Array(length)\n  const sparse = new Uint32Array(length)\n\n  let cursor = 0\n  dense.count = () => cursor + 1\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = cursor\n    dense[cursor] = val\n\n    cursor++\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense[cursor]\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n\n    cursor--\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}\n\nexport const SparseSet = () => {\n  const dense = []\n  const sparse = []\n\n  dense.sort = function (comparator) {\n    const result = Array.prototype.sort.call(this, comparator)\n\n    for(let i = 0; i < dense.length; i++) {\n      sparse[dense[i]] = i\n    }\n    \n    return result\n  }\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = dense.push(val) - 1\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense.pop()\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}","import { $indexBytes, $indexType, $isEidType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\nimport { $localEntities, $localEntityLookup } from \"./World.js\"\n\nexport const DESERIALIZE_MODE = {\n  REPLACE: 0,\n  APPEND: 1,\n  MAP: 2\n}\n\nlet resized = false\n\nexport const setSerializationResized = v => { resized = v }\n\nconst concat = (a,v) => a.concat(v)\nconst not = fn => v => !fn(v)\n\nconst storeFlattened = c => c[$storeFlattened]\nconst isFullComponent = storeFlattened\nconst isProperty = not(isFullComponent)\n\nconst isModifier = c => typeof c === 'function'\nconst isNotModifier = not(isModifier)\n\nconst isChangedModifier = c => isModifier(c) && c()[1] === 'changed'\n\nconst isWorld = w => Object.getOwnPropertySymbols(w).includes($componentMap)\n\nconst fromModifierToComponent = c => c()[0]\n\nexport const canonicalize = target => {\n\n  if (isWorld(target)) return [[],new Map()]\n\n  // aggregate full components\n  const fullComponentProps = target\n    .filter(isNotModifier)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n  \n  // aggregate changed full components\n  const changedComponentProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n\n  // aggregate props\n  const props = target\n    .filter(isNotModifier)\n    .filter(isProperty)\n\n  // aggregate changed props\n  const changedProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isProperty)\n  \n  const componentProps = [...fullComponentProps, ...props, ...changedComponentProps, ...changedProps]\n  const allChangedProps = [...changedComponentProps, ...changedProps].reduce((map,prop) => {\n    const $ = Symbol()\n    createShadow(prop, $)\n    map.set(prop, $)\n    return map\n  }, new Map())\n\n  return [componentProps, allChangedProps]\n}\n\n/**\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\n *\n * @param {object|array} target\n * @param {number} [maxBytes=20000000]\n * @returns {function} serializer\n */\nexport const defineSerializer = (target, maxBytes = 20000000) => {\n  const worldSerializer = isWorld(target)\n\n  let [componentProps, changedProps] = canonicalize(target)\n\n  // TODO: calculate max bytes based on target & recalc upon resize\n\n  const buffer = new ArrayBuffer(maxBytes)\n  const view = new DataView(buffer)\n\n  const entityComponentCache = new Map()\n\n  return (ents) => {\n\n    if (resized) {\n      [componentProps, changedProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (worldSerializer) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n    \n    let world\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\n      world = ents\n      ents = ents[$entityArray]\n    } else {\n      world = eidToWorld.get(ents[0])\n    }\n\n    let where = 0\n\n    if (!ents.length) return buffer.slice(0, where)\n\n    const cache = new Map()\n\n    // iterate over component props\n    for (let pid = 0; pid < componentProps.length; pid++) {\n      const prop = componentProps[pid]\n      const component = prop[$storeBase]()\n      const $diff = changedProps.get(prop)\n      const shadow = $diff ? prop[$diff] : null\n\n      if (!cache.has(component)) cache.set(component, new Map())\n\n      // write pid\n      view.setUint8(where, pid)\n      where += 1\n\n      // save space for entity count\n      const countWhere = where\n      where += 4\n\n      let writeCount = 0\n      // write eid,val\n      for (let i = 0; i < ents.length; i++) {\n        const eid = ents[i]\n\n        let componentCache = entityComponentCache.get(eid)\n        if (!componentCache) componentCache = entityComponentCache.set(eid, new Set()).get(eid)\n        \n        componentCache.add(eid)\n        \n        const newlyAddedComponent = \n          // if we are diffing\n          shadow \n          // and we have already iterated over this component for this entity\n          // retrieve cached value    \n          && cache.get(component).get(eid)\n          // or if entity did not have component last call\n          || !componentCache.has(component)\n          // and entity has component this call\n          && hasComponent(world, component, eid)\n\n        cache.get(component).set(eid, newlyAddedComponent)\n\n        if (newlyAddedComponent) {\n          componentCache.add(component)\n        } else if (!hasComponent(world, component, eid)) {\n          // skip if entity doesn't have this component\n          componentCache.delete(component)\n          continue\n        } \n\n        \n        const rewindWhere = where\n\n        // write eid\n        view.setUint32(where, eid)\n        where += 4\n\n        // if it's a tag store we can stop here\n        if (prop[$tagStore]) {\n          writeCount++\n          continue\n        }\n\n        // if property is an array\n        if (ArrayBuffer.isView(prop[eid])) {\n          const type = prop[eid].constructor.name.replace('Array', '')\n          const indexType = prop[eid][$indexType]\n          const indexBytes = prop[eid][$indexBytes]\n\n          // save space for count of dirty array elements\n          const countWhere2 = where\n          where += indexBytes\n\n          let arrayWriteCount = 0\n\n          // write index,value\n          for (let i = 0; i < prop[eid].length; i++) {\n\n            if (shadow) {\n\n              const changed = shadow[eid][i] !== prop[eid][i]\n              \n              // sync shadow\n              shadow[eid][i] = prop[eid][i]              \n\n              // if state has not changed since the last call\n              // todo: if newly added then entire component will serialize (instead of only changed values)\n              if (!changed && !newlyAddedComponent) {\n                // skip writing this value\n                continue\n              }\n            }\n            \n            // write array index\n            view[`set${indexType}`](where, i)\n            where += indexBytes\n            \n            // write value at that index\n            const value = prop[eid][i]\n            view[`set${type}`](where, value)\n            where += prop[eid].BYTES_PER_ELEMENT\n            arrayWriteCount++\n          }\n\n          if (arrayWriteCount > 0) {\n            // write total element count\n            view[`set${indexType}`](countWhere2, arrayWriteCount)\n            writeCount++\n          } else {\n            where = rewindWhere\n            continue\n          }\n        } else {\n\n          if (shadow) {\n\n            const changed = shadow[eid] !== prop[eid]\n\n            shadow[eid] = prop[eid]\n\n            // do not write value if diffing and no change\n            if (!changed && !newlyAddedComponent) {\n              // rewind the serializer\n              where = rewindWhere\n              // skip writing this value\n              continue\n            }\n\n          }  \n\n\n          const type = prop.constructor.name.replace('Array', '')\n          // set value next [type] bytes\n          view[`set${type}`](where, prop[eid])\n          where += prop.BYTES_PER_ELEMENT\n\n          writeCount++\n        }\n      }\n\n      if (writeCount > 0) {\n        // write how many eid/value pairs were written\n        view.setUint32(countWhere, writeCount)\n      } else {\n        // if nothing was written (diffed with no changes) \n        // then move cursor back 5 bytes (remove PID and countWhere space)\n        where -= 5\n      }\n    }\n    return buffer.slice(0, where)\n  }\n}\n\nconst newEntities = new Map()\n\n/**\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\n *\n * @param {object|array} target\n * @returns {function} deserializer\n */\nexport const defineDeserializer = (target) => {\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\n  let [componentProps] = canonicalize(target)\n\n\n  return (world, packet, mode=0) => {\n\n    const deserializedEntities = []\n\n    newEntities.clear()\n    \n    if (resized) {\n      [componentProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (isWorld) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n\n    const localEntities = world[$localEntities]\n    const localEntityLookup = world[$localEntityLookup]\n\n    const view = new DataView(packet)\n    let where = 0\n\n    while (where < packet.byteLength) {\n\n      // pid\n      const pid = view.getUint8(where)\n      where += 1\n\n      // entity count\n      const entityCount = view.getUint32(where)\n      where += 4\n\n      // component property\n      const prop = componentProps[pid]\n\n      // Get the entities and set their prop values\n      for (let i = 0; i < entityCount; i++) {\n        let eid = view.getUint32(where) // throws with [changed, c, changed]\n        where += 4\n\n        if (mode === DESERIALIZE_MODE.MAP) {\n          if (localEntities.has(eid)) {\n            eid = localEntities.get(eid)\n          } else if (newEntities.has(eid)) {\n            eid = newEntities.get(eid)\n          } else {\n            const newEid = addEntity(world)\n            localEntities.set(eid, newEid)\n            localEntityLookup.set(newEid, eid)\n            newEntities.set(eid, newEid)\n            eid = newEid\n          }\n        }\n\n        if (mode === DESERIALIZE_MODE.APPEND ||  \n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\n        ) {\n          const newEid = newEntities.get(eid) || addEntity(world)\n          newEntities.set(eid, newEid)\n          eid = newEid\n        }\n\n        const component = prop[$storeBase]()\n        if (!hasComponent(world, component, eid)) {\n          addComponent(world, component, eid)\n        }\n\n        // add eid to deserialized ents after it has been transformed by MAP mode\n        deserializedEntities.push(eid)\n\n        if (component[$tagStore]) {\n          continue\n        }\n        \n        if (ArrayBuffer.isView(prop[eid])) {\n          const array = prop[eid]\n          const count = view[`get${array[$indexType]}`](where)\n          where += array[$indexBytes]\n\n          // iterate over count\n          for (let i = 0; i < count; i++) {\n            const index = view[`get${array[$indexType]}`](where)\n            where += array[$indexBytes]\n\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\n            where += array.BYTES_PER_ELEMENT\n            if (prop[$isEidType]) {\n              let localEid = localEntities.get(value)\n              if (!world[$entitySparseSet].has(localEid)) localEid = addEntity(world)\n              prop[eid][index] = localEid\n            } else prop[eid][index] = value\n          }\n        } else {\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\n          where += prop.BYTES_PER_ELEMENT\n\n          if (prop[$isEidType]) {\n            let localEid = localEntities.get(value)\n            if (!world[$entitySparseSet].has(localEid)) localEid = addEntity(world)\n            prop[eid] = localEid\n          } else prop[eid] = value\n        }\n      }\n    }\n\n    return deserializedEntities\n  }\n}","import { resizeComponents } from './Component.js'\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\nimport { $localEntities, $localEntityLookup, resizeWorlds } from './World.js'\nimport { setSerializationResized } from './Serialize.js'\n\nexport const $entityMasks = Symbol('entityMasks')\nexport const $entityComponents = Symbol('entityComponents')\nexport const $entitySparseSet = Symbol('entitySparseSet')\nexport const $entityArray = Symbol('entityArray')\nexport const $entityIndices = Symbol('entityIndices')\nexport const $removedEntities = Symbol('removedEntities')\n\nlet defaultSize = 100000\n\n// need a global EID cursor which all worlds and all components know about\n// so that world entities can posess entire rows spanning all component tables\nlet globalEntityCursor = 0\nlet globalSize = defaultSize\nlet resizeThreshold = () => globalSize - (globalSize / 5)\n\nexport const getGlobalSize = () => globalSize\n\n// removed eids should also be global to prevent memory leaks\nconst removed = []\n\nexport const resetGlobals = () => {\n  globalSize = defaultSize\n  globalEntityCursor = 0\n  removed.length = 0\n}\n\nexport const getDefaultSize = () => defaultSize\n\n/**\n * Sets the default maximum number of entities for worlds and component stores.\n *\n * @param {number} size\n */\nexport const setDefaultSize = size => { \n  defaultSize = size\n  resetGlobals()\n}\n\nexport const getEntityCursor = () => globalEntityCursor\nexport const getRemovedEntities = () => removed\n\nexport const eidToWorld = new Map()\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world) => {\n\n  // if data stores are 80% full\n  if (globalEntityCursor >= resizeThreshold()) {\n    // grow by half the original size rounded up to a multiple of 4\n    const size = globalSize\n    const amount = Math.ceil((size/2) / 4) * 4\n    const newSize = size + amount\n    globalSize = newSize\n    resizeWorlds(newSize)\n    resizeComponents(newSize)\n    setSerializationResized(true)\n    console.info(`ðŸ‘¾ bitECS - resizing all data stores from ${size} to ${newSize}`)\n  }\n\n  const eid = removed.length > 0 ? removed.shift() : globalEntityCursor++\n  \n  world[$entitySparseSet].add(eid)\n  eidToWorld.set(eid, world)\n\n  world[$notQueries].forEach(q => {\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  })\n\n  world[$entityComponents].set(eid, new Set())\n\n  return eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const removeEntity = (world, eid) => {\n  // Check if entity is already removed\n  if (!world[$entitySparseSet].has(eid)) return\n\n  // Remove entity from all queries\n  // TODO: archetype graph\n  world[$queries].forEach(q => {\n    queryRemoveEntity(world, q, eid)\n  })\n\n  // Free the entity\n  removed.push(eid)\n\n  // remove all eid state from world\n  world[$entitySparseSet].remove(eid)\n  world[$entityComponents].delete(eid)\n\n  // remove from deserializer mapping\n  world[$localEntities].delete(world[$localEntityLookup].get(eid))\n  world[$localEntityLookup].delete(eid)\n\n  // Clear entity bitmasks\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world, eid) => Array.from(world[$entityComponents].get(eid))","import { SparseSet } from './Util.js'\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\nimport { $componentMap, registerComponent } from './Component.js'\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\n\n\n\nexport function Not(c) { return () => [c, 'not'] }\nexport function Or(c) { return () => [c, 'or'] }\nexport function Changed(c) { return () => [c, 'changed'] }\n\nexport function Any(...comps) { return function QueryAny() { return comps } }\nexport function All(...comps) { return function QueryAll() { return comps } }\nexport function None(...comps) { return function QueryNone() { return comps } }\n\nexport const $queries = Symbol('queries')\nexport const $notQueries = Symbol('notQueries')\n\nexport const $queryAny = Symbol('queryAny')\nexport const $queryAll = Symbol('queryAll')\nexport const $queryNone = Symbol('queryNone')\n\nexport const $queryMap = Symbol('queryMap')\nexport const $dirtyQueries = Symbol('$dirtyQueries')\nexport const $queryComponents = Symbol('queryComponents')\nexport const $enterQuery = Symbol('enterQuery')\nexport const $exitQuery = Symbol('exitQuery')\n\n/**\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const enterQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  const entered = q.entered.dense.slice()\n  q.entered = SparseSet()\n  return entered\n}\n\n/**\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const exitQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  const exited = q.exited.dense.slice()\n  q.exited = SparseSet()\n  return exited\n}\n\nexport const registerQuery = (world, query) => {\n\n  const components = []\n  const notComponents = []\n  const changedComponents = []\n\n  query[$queryComponents].forEach(c => {\n    if (typeof c === 'function') {\n      const [comp, mod] = c()\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\n      if (mod === 'not') {\n        notComponents.push(comp)\n      }\n      if (mod === 'changed') {\n        changedComponents.push(comp)\n        components.push(comp)\n      }\n      // if (mod === 'all') {\n      //   allComponents.push(comp)\n      // }\n      // if (mod === 'any') {\n      //   anyComponents.push(comp)\n      // }\n      // if (mod === 'none') {\n      //   noneComponents.push(comp)\n      // }\n    } else {\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\n      components.push(c)\n    }\n  })\n\n\n  const mapComponents = c => world[$componentMap].get(c)\n\n  const allComponents = components.concat(notComponents).map(mapComponents)\n\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\n  const sparseSet = SparseSet()\n\n  const archetypes = []\n  // const changed = SparseSet()\n  const changed = []\n  const toRemove = SparseSet()\n  const entered = SparseSet()\n  const exited = SparseSet()\n\n  const generations = allComponents\n    .map(c => c.generationId)\n    .reduce((a,v) => {\n      if (a.includes(v)) return a\n      a.push(v)\n      return a\n    }, [])\n\n  const reduceBitflags = (a,c) => {\n    if (!a[c.generationId]) a[c.generationId] = 0\n    a[c.generationId] |= c.bitflag\n    return a\n  }\n  const masks = components\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  const notMasks = notComponents\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  // const orMasks = orComponents\n  //   .map(mapComponents)\n  //   .reduce(reduceBitmasks, {})\n\n  const hasMasks = allComponents\n    .reduce(reduceBitflags, {})\n\n  const flatProps = components\n    .filter(c => !c[$tagStore])\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\n    .reduce((a,v) => a.concat(v), [])\n\n  const shadows = flatProps.map(prop => {\n      const $ = Symbol()\n      createShadow(prop, $)\n      return prop[$]\n  }, [])\n\n  const q = Object.assign(sparseSet, {\n    archetypes,\n    changed,\n    components,\n    notComponents,\n    changedComponents,\n    allComponents,\n    masks,\n    notMasks,\n    // orMasks,\n    hasMasks,\n    generations,\n    flatProps,\n    toRemove,\n    entered,\n    exited,\n    shadows,\n  })\n  \n  world[$queryMap].set(query, q)\n  world[$queries].add(q)\n  \n  allComponents.forEach(c => {\n    c.queries.add(q)\n  })\n\n  if (notComponents.length) world[$notQueries].add(q)\n\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\n    if (!world[$entitySparseSet].has(eid)) continue\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  }\n}\n\nconst diff = (q, clearDiff) => {\n  if (clearDiff) q.changed = []\n  const { flatProps, shadows } = q\n  for (let i = 0; i < q.dense.length; i++) {\n    const eid = q.dense[i]\n    let dirty = false\n    for (let pid = 0; pid < flatProps.length; pid++) {\n      const prop = flatProps[pid]\n      const shadow = shadows[pid]\n      if (ArrayBuffer.isView(prop[eid])) {\n        for (let i = 0; i < prop[eid].length; i++) {\n          if (prop[eid][i] !== shadow[eid][i]) {\n            dirty = true\n            break\n          }\n        }\n        shadow[eid].set(prop[eid])\n      } else {\n        if (prop[eid] !== shadow[eid]) {\n          dirty = true\n          shadow[eid] = prop[eid]\n        }\n      }\n    }\n    if (dirty) q.changed.push(eid)\n  }\n  return q.changed\n}\n\n// const queryEntityChanged = (q, eid) => {\n//   if (q.changed.has(eid)) return\n//   q.changed.add(eid)\n// }\n\n// export const entityChanged = (world, component, eid) => {\n//   const { changedQueries } = world[$componentMap].get(component)\n//   changedQueries.forEach(q => {\n//     const match = queryCheckEntity(world, q, eid)\n//     if (match) queryEntityChanged(q, eid)\n//   })\n// }\n\nconst flatten = (a,v) => a.concat(v)\n\nconst aggregateComponentsFor = mod => x => x.filter(f => f.name === mod().constructor.name).reduce(flatten)\n\nconst getAnyComponents = aggregateComponentsFor(Any)\nconst getAllComponents = aggregateComponentsFor(All)\nconst getNoneComponents = aggregateComponentsFor(None)\n\n/**\n * Defines a query function which returns a matching set of entities when called on a world.\n *\n * @param {array} components\n * @returns {function} query\n */\n\nexport const defineQuery = (...args) => {\n  let components\n  let any, all, none\n  if (Array.isArray(args[0])) {\n    components = args[0]\n  } else {\n    // any = getAnyComponents(args)\n    // all = getAllComponents(args)\n    // none = getNoneComponents(args)\n  }\n  \n\n  if (components === undefined || components[$componentMap] !== undefined) {\n    return world => world ? world[$entityArray] : components[$entityArray]\n  }\n\n  const query = function (world, clearDiff=true) {\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\n\n    const q = world[$queryMap].get(query)\n\n    commitRemovals(world)\n\n    if (q.changedComponents.length) return diff(q, clearDiff)\n    // if (q.changedComponents.length) return q.changed.dense\n\n    return q.dense\n  }\n\n  query[$queryComponents] = components\n  query[$queryAny] = any\n  query[$queryAll] = all\n  query[$queryNone] = none\n\n  return query\n}\n\nconst bin = value => {\n  if (!Number.isSafeInteger(value)) {\n    throw new TypeError('value must be a safe integer');\n  }\n\n  const negative = value < 0;\n  const twosComplement = negative ? Number.MAX_SAFE_INTEGER + value + 1 : value;\n  const signExtend = negative ? '1' : '0';\n\n  return twosComplement.toString(2).padStart(4, '0').padStart(0, signExtend);\n}\n\n// TODO: archetype graph\nexport const queryCheckEntity = (world, q, eid) => {\n  const { masks, notMasks, generations } = q\n  let or = 0\n  for (let i = 0; i < generations.length; i++) {\n    const generationId = generations[i]\n    const qMask = masks[generationId]\n    const qNotMask = notMasks[generationId]\n    // const qOrMask = orMasks[generationId]\n    const eMask = world[$entityMasks][generationId][eid]\n    \n    // any\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\n    //   continue\n    // }\n    // not all \n    // if (qNotMask && (eMask & qNotMask) === qNotMask) {\n    // }\n    // not any\n    if (qNotMask && (eMask & qNotMask) !== 0) {\n      return false\n    }\n    // all\n    if (qMask && (eMask & qMask) !== qMask) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const queryCheckComponent = (q, c) => {\n  const { generationId, bitflag } = c\n  const { hasMasks } = q\n  const mask = hasMasks[generationId]\n  return (mask & bitflag) === bitflag\n}\n\nexport const queryAddEntity = (q, eid) => {\n  q.toRemove.remove(eid)\n  if (!q.has(eid)) q.entered.add(eid)\n  q.add(eid)\n}\n\nconst queryCommitRemovals = (q) => {\n  for (let i = q.toRemove.dense.length-1; i >= 0; i--) {\n    const eid = q.toRemove.dense[i]\n    q.toRemove.remove(eid)\n    q.remove(eid)\n  }\n}\n\nexport const commitRemovals = (world) => {\n  if (!world[$dirtyQueries].size) return\n  world[$dirtyQueries].forEach(queryCommitRemovals)\n  world[$dirtyQueries].clear()\n}\n\nexport const queryRemoveEntity = (world, q, eid) => {\n  if (!q.has(eid) || q.toRemove.has(eid)) return\n  q.toRemove.add(eid)\n  world[$dirtyQueries].add(q)\n  q.exited.add(eid)\n}\n\n\n/**\n * Resets a Changed-based query, clearing the underlying list of changed entities.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const resetChangedQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  q.changed = []\n}\n\n/**\n * Removes a query from a world.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const removeQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  world[$queries].delete(q)\n  world[$queryMap].delete(query)\n}","import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity, commitRemovals } from './Query.js'\nimport { $bitflag, $size } from './World.js'\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents, getGlobalSize, $entitySparseSet } from './Entity.js'\n\nexport const $componentMap = Symbol('componentMap')\n\nexport const components = []\n\nexport const resizeComponents = (size) => {\n  components.forEach(component => resizeStore(component, size))\n}\n\n\n/**\n * Defines a new component store.\n *\n * @param {object} schema\n * @returns {object}\n */\nexport const defineComponent = (schema) => {\n  const component = createStore(schema, getGlobalSize())\n  if (schema && Object.keys(schema).length) components.push(component)\n  return component\n}\n\nexport const incrementBitflag = (world) => {\n  world[$bitflag] *= 2\n  if (world[$bitflag] >= 2**31) {\n    world[$bitflag] = 1\n    world[$entityMasks].push(new Uint32Array(world[$size]))\n  }\n}\n\n\n/**\n * Registers a component with a world.\n *\n * @param {World} world\n * @param {Component} component\n */\nexport const registerComponent = (world, component) => {\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\n\n  const queries = new Set()\n  const notQueries = new Set()\n  const changedQueries = new Set()\n\n  world[$queries].forEach(q => {\n    if (q.allComponents.includes(component)) {\n      queries.add(q)\n    }\n  })\n\n  world[$componentMap].set(component, { \n    generationId: world[$entityMasks].length - 1,\n    bitflag: world[$bitflag],\n    store: component,\n    queries,\n    notQueries,\n    changedQueries,\n  })\n\n  if (component[$storeSize] < getGlobalSize()) {\n    resizeStore(component, getGlobalSize())\n  }\n\n  incrementBitflag(world)\n}\n\n/**\n * Registers multiple components with a world.\n *\n * @param {World} world\n * @param {Component} components\n */\nexport const registerComponents = (world, components) => {\n  components.forEach(c => registerComponent(world, c))\n}\n\n/**\n * Checks if an entity has a component.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @returns {boolean}\n */\nexport const hasComponent = (world, component, eid) => {\n  const registeredComponent = world[$componentMap].get(component)\n  if (!registeredComponent) return false\n  const { generationId, bitflag } = registeredComponent\n  const mask = world[$entityMasks][generationId][eid]\n  return (mask & bitflag) === bitflag\n}\n\n/**\n * Adds a component to an entity\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=false]\n */\nexport const addComponent = (world, component, eid, reset=true) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\n  if (hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries, notQueries } = c\n    \n  // Add bitflag to entity bitmask\n  world[$entityMasks][generationId][eid] |= bitflag\n\n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).add(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n\n/**\n * Removes a component from an entity and resets component state unless otherwise specified.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=true]\n */\nexport const removeComponent = (world, component, eid, reset=false) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries } = c\n\n  // Remove flag from entity bitmask\n  world[$entityMasks][generationId][eid] &= ~bitflag\n  \n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).delete(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n","import { $componentMap } from './Component.js'\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\nimport { resize } from './Storage.js'\nimport { SparseSet } from './Util.js'\n\nexport const $size = Symbol('size')\nexport const $resizeThreshold = Symbol('resizeThreshold')\nexport const $bitflag = Symbol('bitflag')\nexport const $archetypes = Symbol('archetypes')\nexport const $localEntities = Symbol('localEntities')\nexport const $localEntityLookup = Symbol('localEntityLookp')\n\nexport const worlds = []\n\nexport const resizeWorlds = (size) => {\n  worlds.forEach(world => {\n    world[$size] = size\n\n    for (let i = 0; i < world[$entityMasks].length; i++) {\n      const masks = world[$entityMasks][i];\n      world[$entityMasks][i] = resize(masks, size)\n    }\n    \n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\n  })\n}\n\n/**\n * Creates a new world.\n *\n * @returns {object}\n */\nexport const createWorld = (obj={}) => {\n  const world = obj\n  resetWorld(world)\n  worlds.push(world)\n  return world\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world) => {\n  const size = getGlobalSize()\n  world[$size] = size\n\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\n\n  world[$entityMasks] = [new Uint32Array(size)]\n  world[$entityComponents] = new Map()\n  world[$archetypes] = []\n\n  world[$entitySparseSet] = SparseSet()\n  world[$entityArray] = world[$entitySparseSet].dense\n\n  world[$bitflag] = 1\n\n  world[$componentMap] = new Map()\n\n  world[$queryMap] = new Map()\n  world[$queries] = new Set()\n  world[$notQueries] = new Set()\n  world[$dirtyQueries] = new Set()\n\n  world[$localEntities] = new Map()\n  world[$localEntityLookup] = new Map()\n\n  return world\n}\n\n/**\n * Deletes a world.\n *\n * @param {World} world\n */\nexport const deleteWorld = (world) => {\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\n  Object.keys(world).forEach(key => { delete world[key] })\n  worlds.splice(worlds.indexOf(world), 1)\n}\n","import { createWorld, resetWorld, deleteWorld } from './World.js'\nimport { addEntity, removeEntity, setDefaultSize, getEntityComponents} from './Entity.js'\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\nimport { defineSystem } from './System.js'\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\nimport { parentArray } from './Storage.js'\nimport { TYPES_ENUM } from './Constants.js'\n// import { defineProxy } from './Proxy.js'\n\nexport const pipe = (...fns) => (input) => {\n  let tmp = input\n  for (let i = 0; i < fns.length; i++) {\n    const fn = fns[i]\n    tmp = fn(tmp)\n  }\n  return tmp\n}\n\nexport const Types = TYPES_ENUM\n\nexport {\n\n  setDefaultSize,\n  createWorld,\n  resetWorld,\n  deleteWorld,\n  addEntity,\n  removeEntity,\n\n  registerComponent,\n  registerComponents,\n  defineComponent,\n  addComponent,\n  removeComponent,\n  hasComponent,\n  getEntityComponents,\n  // entityChanged,\n\n  // defineProxy,\n\n  defineQuery,\n  Changed,\n  Not,\n  // Or,\n  enterQuery,\n  exitQuery,\n  commitRemovals,\n  resetChangedQuery,\n  removeQuery,\n\n  defineSystem,\n  \n  defineSerializer,\n  defineDeserializer,\n  DESERIALIZE_MODE,\n\n  parentArray,\n\n}\n","import {\n  createWorld,\n  Types,\n  defineComponent,\n  defineQuery,\n  addEntity,\n  addComponent,\n  pipe,\n} from 'bitecs'\n\nconst Vector3 = { x: Types.f32, y: Types.f32, z: Types.f32 }\nconst Position = defineComponent(Vector3)\nconst Velocity = defineComponent(Vector3)\nconst Shape = defineComponent({ radius: Types.f32, color: Types.f32 })\n\nconst movementQuery = defineQuery([Position, Velocity])\nconst rendererQuery = defineQuery([Position, Velocity, Shape])\n\nconst collisionQuery = defineQuery([Position, Velocity, Shape])\n\nconst collisionSystem = (world) => {\n  const ents = collisionQuery(world)\n\n  for (let i = 0; i < ents.length; i++) {\n    const eid = ents[i]\n    const rest = ents.slice(i + 1)\n    for (let j = 0; j < rest.length; j++) {\n      const id = rest[j]\n\n      var dx = Position.x[eid] - Position.x[id]\n      var dy = Position.y[eid] - Position.y[id]\n      var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2))\n\n      if (distance <= Shape.radius[eid] + Shape.radius[id]) {\n        const vx = Position.x[eid] - Position.x[id]\n        const vy = Position.y[eid] - Position.y[id]\n\n        const unitNormalX = vx / distance\n        const unitNormalY = vy / distance\n        const unitTangentX = -unitNormalY;\n        const unitTangentY = unitNormalX;\n\n        const a_n = Velocity.x[eid] * unitNormalX + Velocity.y[eid] * unitNormalY\n        const b_n = Velocity.x[id] * unitNormalX + Velocity.y[id] * unitNormalY\n        const a_t = Velocity.x[eid] * unitTangentX + Velocity.y[eid] * unitTangentY\n        const b_t = Velocity.x[id] * unitTangentX + Velocity.y[id] * unitTangentY\n\n        const a_n_final = (a_n * (Shape.radius[eid] - Shape.radius[id]) +\n          2 * Shape.radius[id] * b_n) / (Shape.radius[eid] + Shape.radius[id]);\n        const b_n_final = (b_n * (Shape.radius[id] - Shape.radius[eid]) +\n          2 * Shape.radius[eid] * a_n) / (Shape.radius[eid] + Shape.radius[id]);\n\n        const a_n_x = unitNormalX * a_n_final\n        const a_n_y = unitNormalY * a_n_final\n        const b_n_x = unitNormalX * b_n_final\n        const b_n_y = unitNormalY * b_n_final\n\n        const a_t_x = unitTangentX * a_t\n        const a_t_y = unitTangentY * a_t\n        const b_t_x = unitTangentX * b_t\n        const b_t_y = unitTangentY * b_t\n\n        Velocity.x[eid] = a_n_x + a_t_x\n        Velocity.y[eid] = a_n_y + a_t_y\n        Velocity.x[id] = b_n_x + b_t_x\n        Velocity.y[id] = b_n_y + b_t_y\n      }\n    }\n  }\n  return world\n}\n\nconst movementSystem = (world) => {\n  const ents = movementQuery(world)\n  for (let i = 0; i < ents.length; i++) {\n    const eid = ents[i]\n    Position.x[eid] += Velocity.x[eid]\n    Position.y[eid] += Velocity.y[eid]\n    Position.z[eid] += Velocity.z[eid]\n\n    if (Position.x[eid] - Shape.radius[eid] < 0 || Position.x[eid] + Shape.radius[eid] > canvasWidth) {\n      Velocity.x[eid] *= -1.1;\n      // Velocity.x[eid] = -Velocity.x[eid]\n    }\n\n    if (Position.y[eid] - Shape.radius[eid] < 0 || Position.y[eid] + Shape.radius[eid] > canvasHeight) {\n      Velocity.y[eid] *= -1.1;\n      // Velocity.y[eid] = -Velocity.y[eid]\n    }\n  }\n  return world\n}\n\nlet canvas = document.querySelector(\"canvas\");\nlet canvasWidth = canvas.width = window.innerWidth;\nlet canvasHeight = canvas.height = window.innerHeight;\nlet ctx = canvas.getContext(\"2d\");\n\nconst rendererSystem = (world) => {\n  const ents = rendererQuery(world)\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight)\n  for (let i = 0; i < ents.length; i++) {\n    const eid = ents[i]\n\n    ctx.beginPath();\n    ctx.arc(Position.x[eid], Position.y[eid], Shape.radius[eid], 0, 2 * Math.PI);\n    ctx.fillStyle = `hsl(${Shape.color[eid]}, 50%, 50%)`\n    ctx.fill()\n    // ctx.strokeStyle = \"white\";\n    // ctx.stroke();\n  }\n  return world\n}\n\nconst timeSystem = world => {\n  const { time } = world\n  const now = performance.now()\n  const delta = now - time.then\n  time.delta = delta\n  time.elapsed += delta\n  time.then = now\n  return world\n}\n\nconst pipeline = pipe(movementSystem, collisionSystem, rendererSystem, timeSystem)\n\nconst world = createWorld()\nworld.time = { delta: 0, elapsed: 0, then: performance.now() }\n\nconst generateEntity = (x, y, vx, vy, radius) => {\n  const eid = addEntity(world)\n  addComponent(world, Position, eid)\n  Position.x[eid] = x\n  Position.y[eid] = y\n\n  addComponent(world, Velocity, eid)\n  Velocity.x[eid] = vx\n  Velocity.y[eid] = vy\n\n  addComponent(world, Shape, eid)\n  Shape.radius[eid] = radius\n  Shape.color[eid] = Math.random() * 360\n}\n\nconst DESIRED_NUM_OBJECTS = 100\nconst MIN_RADIUS = 8\nconst MAX_RADIUS = 30\nconst SPEED_MULTIPLIER = .4;\n\nconst safeAreas = []\nconst size = MAX_RADIUS * 2\nconst start = MAX_RADIUS\nconst maxHeight = canvasHeight - MAX_RADIUS\nconst maxWidth = canvasWidth - MAX_RADIUS\n\nfor (let x = start; x < maxWidth; x += size) {\n  for (let y = start; y < maxHeight; y += size) {\n    safeAreas.push({ x: x, y: y})\n  }\n}\n\nfunction randomRange(min, max) {\n  return Math.random() * (max - min) + min\n}\n\nconst maxCells = Math.min(DESIRED_NUM_OBJECTS, safeAreas.length)\nfor (let i = 0; i < maxCells; i++) {\n  const randomIndex = Math.floor(Math.random() * safeAreas.length)\n  const safeArea = safeAreas.splice(randomIndex, 1)[0]\n\n  generateEntity(\n    safeArea.x,\n    safeArea.y,\n    SPEED_MULTIPLIER * (2 * Math.random() - 1),\n    SPEED_MULTIPLIER * (2 * Math.random() - 1),\n    Math.floor(randomRange(MIN_RADIUS, MAX_RADIUS))\n  )\n}\nwindow.generateEntity = generateEntity\n// generateEntity(40, 40, SPEED_MULTIPLIER * (2 * Math.random() - 1), SPEED_MULTIPLIER * (2 * Math.random() - 1), MAX_RADIUS)\n// generateEntity(40, 280, SPEED_MULTIPLIER * (2 * Math.random() - 1), SPEED_MULTIPLIER * (2 * Math.random() - 1), MAX_RADIUS)\n\nconst run = () => {\n  pipeline(world)\n  requestAnimationFrame(run)\n}\nwindow.run = run\nrun()\n\n// setInterval(() => {\n//   pipeline(world)\n// }, 16)\n\n// // Run!\n// function run() {\n//   // Compute delta and elapsed time\n//   var time = performance.now();\n//   var delta = time - lastTime;\n//   // Run all the systems\n//   world.execute(delta, time);\n//   lastTime = time;\n//   requestAnimationFrame(run);\n// }\n// var lastTime = performance.now();\n// run();\n\n\n\n\n\n// import {\n//   createWorld,\n//   Types,\n//   defineComponent,\n//   defineQuery,\n//   addEntity,\n//   addComponent,\n//   pipe,\n// } from 'bitecs'\n// import InputManager from './input-manager'\n\n// const input = new InputManager(window)\n// input.addEventListeners()\n\n// const SHAPE_ASTEROID = 0\n// const SHAPE_SPACESHIP = 1\n\n// const Vector3 = { x: Types.f32, y: Types.f32, z: Types.f32 }\n// const Position = defineComponent(Vector3)\n// const Velocity = defineComponent(Vector3)\n// const PlayerControlled = defineComponent()\n// const Asteroid = defineComponent()\n// const Shape = defineComponent({ type: Types.f32 })\n\n// const movementQuery = defineQuery([Position, Velocity])\n// const motionControlQuery = defineQuery([Position, Velocity, PlayerControlled])\n// const rendererQuery = defineQuery([Position, Velocity, Shape])\n\n// // asteroids collide with player (game over)\n// // bullets collide with asteroid (hit)\n// // asteroids DO NOT COLLIDE with other asteroids\n\n// const asteroidQuery = defineQuery([Position, Velocity, Asteroid])\n// const playerQuery = defineQuery([Position, Velocity, PlayerControlled])\n\n// const collisionSystem = (world) => {\n//   const player = playerQuery(world)\n//   const ents = asteroidQuery(world)\n\n//   for (let i = 0; i < player.length; i++) {\n//     const eid = player[i]\n\n//     for (let j = 0; j < ents.length; j++) {\n//       const id = ents[j]\n\n//       if (eid === id) {\n//         continue;\n//       }\n\n//       const radius = 10\n//       var dx = (Position.x[eid] + radius) - (Position.x[id] + radius);\n//       var dy = (Position.y[eid] + radius) - (Position.y[id] + radius);\n//       var distance = Math.sqrt(dx * dx + dy * dy);\n\n//       if (distance < radius + radius) {\n//         console.log(\"collision detected\")\n//         Velocity.x[eid] *= -1\n//         Velocity.y[eid] *= -1\n//         Velocity.x[id] *= -1\n//         Velocity.y[id] *= -1\n//       }\n//     }\n//   }\n\n//   // // for (let i = 0; i < ents.length; i++) {\n//   // //   const eid = ents[i]\n\n//   // //   for (let j = 0; j < ents.length; j++) {\n//   // //     const id = ents[j]\n\n//   // //     if (eid === id) {\n//   // //       continue;\n//   // //     }\n\n//   //     const radius = 10\n//   //     const eid = 0\n//   //     const id = 1\n//   //     var dx = (Position.x[eid] + radius) - (Position.x[id] + radius);\n//   //     var dy = (Position.y[eid] + radius) - (Position.y[id] + radius);\n//   //     var distance = Math.sqrt(dx * dx + dy * dy);\n\n//   //     if (distance < radius + radius) {\n//   //       console.log(\"collision detected\")\n//   //       Velocity.x[eid] *= -1\n//   //       Velocity.y[eid] *= -1\n//   //       Velocity.x[id] *= -1\n//   //       Velocity.y[id] *= -1\n//   //     }\n//   // //   }\n//   // // }\n//   return world\n// }\n\n// const movementSystem = (world) => {\n//   const ents = movementQuery(world)\n//   for (let i = 0; i < ents.length; i++) {\n//     const eid = ents[i]\n//     Position.x[eid] += Velocity.x[eid]\n//     Position.y[eid] += Velocity.y[eid]\n//     Position.z[eid] += Velocity.z[eid]\n//   }\n//   return world\n// }\n\n// const motionControlSystem = (world) => {\n//   const ents = motionControlQuery(world)\n//   for (let i = 0; i < ents.length; i++) {\n//     const eid = ents[i]\n//     if (input.keyPoll.up !== 0) {\n//       Velocity.y[eid] -= 0.01\n//     } else if (input.keyPoll.down !== 0) {\n//       Velocity.y[eid] += 0.01\n//     }\n//     if (input.keyPoll.left !== 0) {\n//       Velocity.x[eid] -= 0.01\n//     } else if (input.keyPoll.right !== 0) {\n//       Velocity.x[eid] += 0.01\n//     }\n//   }\n//   return world\n// }\n\n// let canvas = document.querySelector(\"canvas\");\n// let canvasWidth = canvas.width = window.innerWidth;\n// let canvasHeight = canvas.height = window.innerHeight;\n// let ctx = canvas.getContext(\"2d\");\n\n// const rendererSystem = (world) => {\n//   const ents = rendererQuery(world)\n//   ctx.clearRect(0, 0, canvasWidth, canvasHeight)\n//   for (let i = 0; i < ents.length; i++) {\n//     const eid = ents[i]\n\n//     if (Shape.type[eid] === SHAPE_ASTEROID) {\n//       ctx.beginPath();\n//       ctx.arc(Position.x[eid], Position.y[eid], 10, 0, 2 * Math.PI);\n//       ctx.strokeStyle = \"white\";\n//       ctx.stroke();\n//     }\n//     else if (Shape.type[eid] === SHAPE_SPACESHIP) {\n//       ctx.beginPath();\n//       ctx.arc(Position.x[eid], Position.y[eid], 10, 0, 2 * Math.PI);\n//       ctx.fillStyle = \"white\";\n//       ctx.fill();\n//     }\n//   }\n//   return world\n// }\n\n// const timeSystem = world => {\n//   const { time } = world\n//   const now = performance.now()\n//   const delta = now - time.then\n//   time.delta = delta\n//   time.elapsed += delta\n//   time.then = now\n//   return world\n// }\n\n// const pipeline = pipe(motionControlSystem, movementSystem, collisionSystem, rendererSystem, timeSystem)\n\n// const world = createWorld()\n// world.time = { delta: 0, elapsed: 0, then: performance.now() }\n\n// const generateAsteroid = (x, y) => {\n//   const eid = addEntity(world)\n//   addComponent(world, Asteroid, eid)\n\n//   addComponent(world, Position, eid)\n//   Position.x[eid] = x\n//   Position.y[eid] = y\n\n//   addComponent(world, Velocity, eid)\n//   Velocity.x[eid] = 0.1\n//   Velocity.y[eid] = 0.1\n\n//   addComponent(world, Shape, eid)\n//   Shape.type[eid] = SHAPE_ASTEROID\n// }\n\n// generateAsteroid(0, 0)\n// generateAsteroid(50, 0)\n\n// const createPlayer = (x, y, vx, vy) => {\n//   const eid = addEntity(world)\n//   addComponent(world, PlayerControlled, eid)\n//   addComponent(world, Position, eid)\n//   Position.x[eid] = x\n//   Position.y[eid] = y\n//   addComponent(world, Velocity, eid)\n//   Velocity.x[eid] = vx\n//   Velocity.y[eid] = vy\n//   addComponent(world, Shape, eid)\n//   Shape.type[eid] = SHAPE_SPACESHIP\n// }\n\n// createPlayer(100, 0, -0.1, 0.1)\n\n// const run = () => {\n//   pipeline(world)\n//   requestAnimationFrame(run)\n// }\n// run()\n\n// // setInterval(() => {\n// //   pipeline(world)\n// // }, 16)\n\n// // // Run!\n// // function run() {\n// //   // Compute delta and elapsed time\n// //   var time = performance.now();\n// //   var delta = time - lastTime;\n// //   // Run all the systems\n// //   world.execute(delta, time);\n// //   lastTime = time;\n// //   requestAnimationFrame(run);\n// // }\n// // var lastTime = performance.now();\n// // run();\n"],"names":["mul","$57ac90409d4f0917$var$TYPES_ENUM","i8","ui8","ui8c","i16","ui16","i32","ui32","f32","f64","eid","$57ac90409d4f0917$var$TYPES_NAMES","$57ac90409d4f0917$var$TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","$57ac90409d4f0917$var$UNSIGNED_MAX","$57ac90409d4f0917$var$roundToMultiple4","x","Math","ceil","$57ac90409d4f0917$var$$storeRef","Symbol","$57ac90409d4f0917$var$$storeSize","$57ac90409d4f0917$var$$storeMaps","$57ac90409d4f0917$var$$storeFlattened","$57ac90409d4f0917$var$$storeBase","$57ac90409d4f0917$var$$storeType","$57ac90409d4f0917$var$$storeArrayElementCounts","$57ac90409d4f0917$var$$storeSubarrays","$57ac90409d4f0917$var$$subarrayCursors","$57ac90409d4f0917$var$$subarray","$57ac90409d4f0917$var$$subarrayFrom","$57ac90409d4f0917$var$$subarrayTo","$57ac90409d4f0917$var$$parentArray","$57ac90409d4f0917$var$$tagStore","$57ac90409d4f0917$var$$indexType","$57ac90409d4f0917$var$$indexBytes","$57ac90409d4f0917$var$$isEidType","$57ac90409d4f0917$var$stores","$57ac90409d4f0917$var$resize","ta","size","newBuffer","ArrayBuffer","BYTES_PER_ELEMENT","newTa","constructor","set","$57ac90409d4f0917$var$createShadow","store","key","isView","slice","shadowStore","map","_","from","to","subarray","$57ac90409d4f0917$var$resizeRecursive","metadata","Object","keys","forEach","Array","isArray","cursors","type","length","indexType","arrayElementCount","array","start","end","$57ac90409d4f0917$var$resizeSubarray","push","$57ac90409d4f0917$var$resizeStore","k","$57ac90409d4f0917$var$resetStoreFor","fill","$57ac90409d4f0917$var$isArrayType","$57ac90409d4f0917$var$createStore","schema","$store","JSON","parse","stringify","arrayElementCounts","collectArrayElementCounts","s","reduce","a","recursiveTransform","totalBytes","buffer","$57ac90409d4f0917$var$createTypeStore","Error","$57ac90409d4f0917$var$createArrayStore","assign","$57ac90409d4f0917$var$SparseSet","dense","sparse","sort","comparator","result","prototype","call","this","i","has","val","index","swapped","pop","$57ac90409d4f0917$var$not","fn","v","$57ac90409d4f0917$var$storeFlattened","c","$57ac90409d4f0917$var$isFullComponent","$57ac90409d4f0917$var$isModifier","$57ac90409d4f0917$var$$entityMasks","Map","$57ac90409d4f0917$var$$entityComponents","$57ac90409d4f0917$var$$entitySparseSet","$57ac90409d4f0917$var$$entityArray","$57ac90409d4f0917$var$defaultSize","$57ac90409d4f0917$var$globalEntityCursor","$57ac90409d4f0917$var$globalSize","$57ac90409d4f0917$var$getGlobalSize","$57ac90409d4f0917$var$removed","$57ac90409d4f0917$var$eidToWorld","$57ac90409d4f0917$export$3317e1f62cf4b778","world","newSize","$57ac90409d4f0917$var$resizeWorlds","$57ac90409d4f0917$var$resizeComponents","console","info","shift","add","$57ac90409d4f0917$var$$notQueries","q","$57ac90409d4f0917$var$queryCheckEntity","$57ac90409d4f0917$var$queryAddEntity","Set","$57ac90409d4f0917$var$$queries","$57ac90409d4f0917$var$$queryAny","$57ac90409d4f0917$var$$queryAll","$57ac90409d4f0917$var$$queryNone","$57ac90409d4f0917$var$$queryMap","$57ac90409d4f0917$var$$dirtyQueries","$57ac90409d4f0917$var$$queryComponents","$57ac90409d4f0917$var$registerQuery","query","components2","notComponents","changedComponents","comp","mod","$57ac90409d4f0917$var$$componentMap","$57ac90409d4f0917$export$d74092cddf07c0aa","mapComponents","get","allComponents","concat","sparseSet","toRemove","entered","exited","generations","generationId","includes","reduceBitflags","bitflag","masks","notMasks","hasMasks","flatProps","filter","getOwnPropertySymbols","shadows","prop","$","components","queries","$57ac90409d4f0917$var$flatten","$57ac90409d4f0917$var$aggregateComponentsFor","f","name","$57ac90409d4f0917$export$331eb332a8bb4fb4","comps","args","clearDiff","$57ac90409d4f0917$export$58c55f3057863312","changed","dirty","pid","shadow","i2","$57ac90409d4f0917$var$diff","any","all","none","qMask","qNotMask","eMask","remove","$57ac90409d4f0917$var$queryCommitRemovals","clear","$57ac90409d4f0917$var$queryRemoveEntity","$57ac90409d4f0917$var$components","component","$57ac90409d4f0917$export$afa64b67e5a01c3b","notQueries","changedQueries","$57ac90409d4f0917$var$$bitflag","$57ac90409d4f0917$var$$size","$57ac90409d4f0917$var$incrementBitflag","$57ac90409d4f0917$export$461a9eb9a78efb9d","registeredComponent","$57ac90409d4f0917$export$17578421efdb3356","reset","match","$57ac90409d4f0917$var$$resizeThreshold","$57ac90409d4f0917$var$$archetypes","$57ac90409d4f0917$var$$localEntities","$57ac90409d4f0917$var$$localEntityLookup","$57ac90409d4f0917$var$worlds","$57ac90409d4f0917$export$bee91ba11c413282","delete","$57ac90409d4f0917$export$7865014fe05c5f81","$57ac90409d4f0917$export$4624c240901a6889","$23a0a60454601d99$var$Vector3","y","z","$23a0a60454601d99$var$Position","$23a0a60454601d99$var$Velocity","$23a0a60454601d99$var$Shape","radius","color","$23a0a60454601d99$var$movementQuery","$23a0a60454601d99$var$rendererQuery","$23a0a60454601d99$var$collisionQuery","$23a0a60454601d99$var$canvas","document","querySelector","$23a0a60454601d99$var$canvasWidth","width","window","innerWidth","$23a0a60454601d99$var$canvasHeight","height","innerHeight","$23a0a60454601d99$var$ctx","getContext","$23a0a60454601d99$var$pipeline","fns","input","tmp","$57ac90409d4f0917$export$a4627e546088548d","ents","rest","j","id","dx","dy","distance","sqrt","pow","unitNormalX","unitNormalY","unitTangentX","unitTangentY","a_n","b_n","a_t","b_t","a_n_final","b_n_final","a_n_x","a_n_y","b_n_x","b_n_y","a_t_x","a_t_y","b_t_x","b_t_y","clearRect","beginPath","arc","PI","fillStyle","time","now","performance","delta","then","elapsed","$23a0a60454601d99$var$world","obj","$57ac90409d4f0917$export$bd9127779b59056d","$23a0a60454601d99$var$generateEntity","vx","vy","random","$23a0a60454601d99$var$safeAreas","$23a0a60454601d99$var$maxHeight","$23a0a60454601d99$var$maxWidth","x1","$23a0a60454601d99$var$MAX_RADIUS","y1","$23a0a60454601d99$var$maxCells","min","i1","randomIndex","floor","safeArea","splice","max","generateEntity","$23a0a60454601d99$var$run","requestAnimationFrame","run"],"version":3,"file":"bitecs-circle-collision.a2d8a8fd.js.map"}